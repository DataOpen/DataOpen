use iron::headers::ContentType;
use iron::mime;
use iron::mime::{Attr, Mime, TopLevel, SubLevel};
use iron::modifiers::Header;
use iron::prelude::*;
use iron::status;
use iron::typemap;
use mysql::IsolationLevel::RepeatableRead;
use mysql::{Pool, Transaction};
use persistent;
use serde::ser::Serialize;
use serde_json;
use std::sync::Arc;

pub mod notebook;
pub mod notebook_history;
pub mod uid;

pub fn content_type() -> Header<ContentType> {
    Header(ContentType(Mime(
    TopLevel::Application,
    SubLevel::Json,
    vec![(Attr::Charset, mime::Value::Utf8)])
    ))
}

pub fn commit(transaction: Transaction) -> Result<(), IronError> {
    match transaction.commit() {
        Ok(_) => Ok(()),
        Err(err) => Err(IronError::new(
            err,
            status::InternalServerError
        )),
    }
}

pub fn json<T>(v: &T) -> Result<String, IronError>
    where T: Serialize {
    match serde_json::to_string(v) {
        Ok(v) => Ok(v),
        Err(err) => return Err(IronError::new(
            err,
            status::InternalServerError
        )),
    }
}

pub fn transaction(mysql_pool: &Pool) -> Result<Transaction, IronError> {
    match mysql_pool.start_transaction(
        true,
        Some(RepeatableRead),
        None
    ) {
        Ok(transaction) => Ok(transaction),
        Err(err) => return Err(IronError::new(
            err,
            status::InternalServerError
        )),
    }
}

pub fn resource<T>(req: &mut Request) -> Arc<<T as typemap::Key>::Value>
    where T: typemap::Key + Sync,
          <T as typemap::Key>::Value: Send + Sync {
    req.get::<persistent::Read<T>>().unwrap()
}
